import Libs.immlib as immlib
import getopt
import Libs.immutils
from Libs.immutils import *
import re


def reset_file(file1):
    FILE = open(file1, "w")
    FILE.write("")
    FILE.close()
    return ""


def to_file(info, filename):
    info = info.replace('\n', ' - ')
    FILE = open(filename, "a")
    FILE.write(info + "\n")
    FILE.close()
    return ""


DESC = "my py_command"

imm = immlib.Debugger()

"""
Main function --> simple assembler
"""


def main(args):

    # ---- Name and path ----
    name = imm.getDebuggedName()
    imm.log("Name : %s" % name)
    me = imm.getModule(name)
    path = me.getPath()
    imm.log("Path : %s" % path)

    # ---- Simple Assembler ----
    if args[0] == "assemble":
        if len(args) < 2:
            imm.log("  Usage : !plugin compare instructions")
            imm.log("           separate multiple instructions with #")
        else:
            cnt = 1
            cmdInput = ""
            while cnt < len(args):
                cmdInput = cmdInput + args[cnt] + " "
                cnt = cnt + 1
            cmdInput = cmdInput.replace("'", "")
            cmdInput = cmdInput.replace('"', '')
            splitter = re.compile('#')
            instructions = splitter.split(cmdInput)
            for instruct in instructions:
                try:
                    assembled = imm.assemble(instruct)
                    strAssembled = ""
                    for assemOpc in assembled:
                        strAssembled = strAssembled + hex(ord(assemOpc)).replace('0x', '\\x')
                    imm.log(" %s = %s" % (instruct, strAssembled))
                except:
                    imm.log("   Could not assemble %s " % instruct)
                    continue

# ------ Table Creation -----
# else:
#    # create table
#   table = imm.createTable('Argument table', ['Number', 'Argument'])
#    imm.log("Number of arguments : %d " % len(args))
#    cnt = 0
#    while cnt < len(args):
#        table.add(0, ["%d" % (cnt + 1), "%s" % (args[cnt])])
#        cnt = cnt + 1


# ----- Search For -----
# else:
#     imm.log("Started search for jmp esp...")
#     imm.updateLog()
#     searchFor = "jmp esp"
#     results = imm.search(imm.assemble(searchFor))
#     for result in results:
#         imm.log("Found %s at 0x%08x " % (searchFor, result), address=result)


# ----- Search For -----
# else:
#     reset_file("log_immunity.txt")
#     to_file("hello world!", "log_immunity.txt")
#     imm.log("Started search for push esp / ret... now for real")
#     imm.updateLog()
#     searchFor = "push esp\nret"
#     results = imm.search(imm.assemble(searchFor))
#     for result in results:
#         imm.log("Found %s at 0x%08x " % (searchFor.replace('\n', ' - '), result), address=result)

# ---- Read memory ----
# if (args[0]=="readmem"):
#    if (len(args) > 1):
#       imm.Log("Reading 8 bytes of memory at %s " % args[1])
#       cnt=0
#       memloc=int(args[1],16)
#       while (cnt < 8):
#          memchar = imm.readMemory(memloc+cnt,1)
#          memchar2 = hex(ord(memchar)).replace('0x','')
#          imm.Log("Byte %d : %s" % (cnt+1,memchar2))
#          cnt=cnt+1

# ---- Registers ----
# regs = imm.getRegs()
# for reg in regs:
#    imm.Log("Register %s : 0x%08X " % (reg,regs[reg]))


# ---- SehChain --- --> Structured exception handling
# if (args[0]=="sehchain"):
#    thissehchain=imm.getSehChain()
#    sehtable=imm.createTable('SEH Chain',['Address','Value'])
#    for chainentry in thissehchain:
#       sehtable.add(0,("0x%08x"%(chainentry[0]),("%08x"%(chainentry[1]))))

# if (args[0]=="test"):
#    imm.Log("Started search for mov ebp,esp ")
#    imm.updateLog()
#    searchFor="\x8b\xec" #mov ebp,esp / ret
#    results=imm.Search( searchFor )
#    for result in results:
#       opc = imm.Disasm( result )
#       opstring=opc.getDisasm()
#       module = imm.findModule(result)
#       if not module:
#          module="none"
#       else:
#          page = imm.getMemoryPagebyAddress( result )
#          access = page.getAccess( human = True )
#          mod=imm.getModule(module[0])
#          mzbase=mod.getBaseAddress()
#          peoffset=struct.unpack('flags=struct.unpack('unpack('if numberofentries>10:
#             sectionaddress,sectionsize=struct.unpack('data=struct.unpack('data))
#             if condition==False:
#               imm.Log("Module %s is not safeseh protected" % module[0],highlight=1)
#               continue
#          if (flags&0x0040)==0:
#             extrastring="not ASLR aware"
#          else:
#             extrastring="ASLR protected"
#          imm.Log("Found %s at 0x%08x - [module %s] - access %s - ASLR : %s " % (opstring, result,module[0],access,extrastring), address = result)
