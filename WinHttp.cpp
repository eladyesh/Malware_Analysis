// helpful_functions.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <winternl.h>
#include <vector>
#include <shlwapi.h>
#include <winhttp.h>
#include <Ip2string.h>
#pragma comment(lib, "Ntdll.lib")

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable:4996)

#pragma comment(lib, "shlwapi")
#pragma comment(lib, "winhttp")

typedef NTSTATUS(WINAPI* NtCreateFileFunction)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    PLARGE_INTEGER     AllocationSize,
    ULONG              FileAttributes,
    ULONG              ShareAccess,
    ULONG              CreateDisposition,
    ULONG              CreateOptions,
    PVOID              EaBuffer,
    ULONG              EaLength
    );

typedef NTSTATUS(WINAPI* NtWriteFileFunction)(
    HANDLE           FileHandle,
    HANDLE           Event,
    PIO_APC_ROUTINE  ApcRoutine,
    PVOID            ApcContext,
    PIO_STATUS_BLOCK IoStatusBlock,
    PVOID            Buffer,
    ULONG            Length,
    PLARGE_INTEGER   ByteOffset,
    PULONG           Key
    );

struct PE {

    LPVOID pPE;
    DWORD size;

};

char* EnVariable(char* variable) {
    char lpName[MAX_PATH];
    char lpBuffer[MAX_PATH];
    DWORD  nSize = MAX_PATH;
    if (!GetEnvironmentVariableA(variable, lpBuffer, nSize)) {
        printf("Failed in GetEnvironmentVariableA (%u)\n", GetLastError());
        return NULL;
    }

    return lpBuffer;
}

BOOL mkdir(const char* dirName) {

    if (PathFileExistsA(dirName)) {
        printf("[!] \"%s\" already exist\n", dirName);
        return TRUE;
    }


    BOOL successC = CreateDirectoryA(dirName, NULL);
    if (!successC) {
        return FALSE;
    }


    return TRUE;
}

int main()
{
    HINTERNET hSession = WinHttpOpen(L"Example/1.0", WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
    HINTERNET hConnect = WinHttpConnect(hSession, L"www.example.com", INTERNET_DEFAULT_HTTP_PORT, 0);
    HINTERNET hRequest = WinHttpOpenRequest(hConnect, L"GET", L"/", NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    BOOL bResult = WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0);

    if (bResult) {
        bResult = WinHttpReceiveResponse(hRequest, NULL);
    }

    if (bResult) {
        DWORD dwSize = 0;
        DWORD dwDownloaded = 0;

        HANDLE hFile = NULL;
        NtCreateFileFunction NtCreateFile = (NtCreateFileFunction)GetProcAddress(GetModuleHandle(L"ntdll"), "NtCreateFile");
        NtWriteFileFunction NtWriteFile = (NtWriteFileFunction)GetProcAddress(GetModuleHandle(L"ntdll"), "NtWriteFile");

        UNICODE_STRING objectName;
        RtlInitUnicodeString(&objectName, L"Example.txt");

        OBJECT_ATTRIBUTES objectAttributes;
        InitializeObjectAttributes(&objectAttributes, &objectName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);

        IO_STATUS_BLOCK ioStatusBlock;
        LARGE_INTEGER byteOffset;

        // Read data
        NTSTATUS status = NtCreateFile(&hFile, GENERIC_WRITE, &objectAttributes, &ioStatusBlock, NULL, FILE_ATTRIBUTE_NORMAL, FILE_SHARE_READ, FILE_OVERWRITE_IF, FILE_NON_DIRECTORY_FILE, NULL, 0);
        if (!NT_SUCCESS(status)) {
            std::cout << "NtCreateFile failed with status: " << status << std::endl;
            return 1;
        }

        do {
            dwSize = 0;
            if (!WinHttpQueryDataAvailable(hRequest, &dwSize)) {
                std::cout << "WinHttpQueryDataAvailable failed with error: " << GetLastError() << std::endl;
                break;
            }

            if (!dwSize) {
                break;
            }

            char* pszOutBuffer = new char[dwSize + 1];
            if (!pszOutBuffer) {
                std::cout << "Out of memory" << std::endl;
                break;
            }

            ZeroMemory(pszOutBuffer, dwSize + 1);

            if (!WinHttpReadData(hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded)) {
                std::cout << "WinHttpReadData failed with error: " << GetLastError() << std::endl;
            }
            else {
                byteOffset.QuadPart = ioStatusBlock.Information; // keep track of location in NtWriteFile
                status = NtWriteFile(hFile, NULL, NULL, NULL, &ioStatusBlock, pszOutBuffer, dwDownloaded, &byteOffset, NULL);
                if (!NT_SUCCESS(status)) {
                    std::cout << "NtWriteFile failed with status: " << status << std::endl;
                }
            }

            delete[] pszOutBuffer;
        } while (dwSize > 0);

        WinHttpCloseHandle(hFile);
        WinHttpCloseHandle(hRequest);
        WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hSession);

        int x;
        std::cin >> x;
        return 0;
    }
}

